* What Is This
A mashup of my current knavemacs configuration, snippets from
SystemCrafters, and a lot of copy-paste from LionyxML's emacs-solo
configuration.  The goal is to minimize the number of external
packages I pull into emacs.
* Prerequsites
- ripgrep
- JetBrainsMono Nerd Font
* Configuration
** Early Init
Gracefully picked up from https://github.com/LionyxML/emacs-solo

** Emacs General Config
#+BEGIN_SRC elisp
  (use-package emacs
    :ensure nil
    :bind
    (("M-o" . other-window)
     ("M-d" . duplicate-dwim)
     ("M-L" . enlarge-window-horizontally)
     ("M-K" . shrink-window)
     ("M-J" . enlarge-window)
     ("M-H" . shrink-window-horizontally)
     ("M-l" . windmove-right)
     ("M-k" . windmove-up)
     ("M-j" . windmove-down)
     ("M-h" . windmove-left)
     ("M-g r" . recentf)
     ("M-s g" . grep)
     ("C-x ;" . comment-line)
     ("M-s f" . find-name-dired)
     ("C-x C-b" . ibuffer)
     ("RET" . newline-and-indent))
    :custom
    (ad-redefinition-action 'accept)
    (column-number-mode nil)
    (line-number-mode nil)
    (completion-ignore-case t)
    (completions-detailed t)
    (delete-by-moving-to-trash t)
    (display-line-numbers-width 3)
    (display-line-numbers-widen t)
    (delete-selection-mode 1)
    (enable-recursive minibuffers t)
    (find-ls-option '("-exec ls -ldh {} +" . "-ldh"))  ; find-dired results with human readable sizes
    (frame-resize-pixelwise t)
    (global-auto-revert-non-file-buffers t)
    (help-window-select t)
    (history-length 300)
    (inhibit-startup-message t)
    (initial-scratch-message "")
    (ispell-dictionary "en_US")
    (kill-do-not-save-duplicates t)
    (create-lockfiles nil)   ; No backup files
    (make-backup-files nil)  ; No backup files
    (backup-inhibited t)     ; No backup files
    (pixel-scroll-precision-mode t)
    (pixel-scroll-precision-use-momentum nil)
    (ring-bell-function 'ignore)
    (read-answer-short t)
    (recentf-max-saved-items 300) ; default is 20
    (recentf-max-menu-items 15)
    (recentf-auto-cleanup (if (daemonp) 300 'never))
    (recentf-exclude (list "^/\\(?:ssh\\|su\\|sudo\\)?:"))
    (remote-file-name-inhibit-delete-by-moving-to-trash t)
    (remote-file-name-inhibit-auto-save t)
    (resize-mini-windows 'grow-only)
    (ring-bell-function #'ignore)
    (scroll-conservatively 8)
    (scroll-margin 0)
    (savehist-save-minibuffer-history t)    ; t is default
    (savehist-additional-variables
     '(kill-ring                            ; clipboard
       register-alist                       ; macros
       mark-ring global-mark-ring           ; marks
       search-ring regexp-search-ring))     ; searches
    (save-place-file (expand-file-name "saveplace" user-emacs-directory))
    (save-place-limit 600)
    (set-mark-command-repeat-pop t) ; So we can use C-u C-SPC C-SPC C-SPC... instead of C-u C-SPC C-u C-SPC...
    (split-width-threshold 170)     ; So vertical splits are preferred
    (split-height-threshold nil)
    (shr-use-colors nil)
    (switch-to-buffer-obey-display-actions t)
    (tab-always-indent 'complete)
    (tab-width 4)
    (treesit-font-lock-level 4)
    (truncate-lines t)
    (undo-limit (* 13 160000))
    (undo-strong-limit (* 13 240000))
    (undo-outer-limit (* 13 24000000))
    (use-dialog-box nil)
    (use-file-dialog nil)
    (use-package-hook-name-suffix nil)
    (use-short-answers t)
    (visible-bell nil)
    (window-combination-resize t)
    (window-resize-pixelwise nil)
    (xref-search-program 'ripgrep)
    (grep-command "rg -nS --no-heading ")
    (grep-find-ignored-directories
     '("SCCS" "RCS" "CVS" "MCVS" ".src" ".svn" ".git" ".hg" ".bzr" "_MTN" "_darcs" "{arch}" "node_modules" "build" "dist"))
    :config
    ;; Font and Theme Configuration
    (load-theme 'manoj-dark t)
    (add-to-list 'default-frame-alist
  			   '(font . "JetBrainsMono NF 12"))
    ;; Set line-number-mode with relative numbering
    (defun minknavemacs/no-line-nums-hook ()
  	(display-line-numbers-mode 0))
    (setq display-line-numbers-type 'relative)
    (global-display-line-numbers-mode t)
    (dolist (mode '(term-mode-hook
  				  eshell-mode-hook
  				  dired-mode-hook))
  	(add-hook mode 'minknavemacs/no-line-nums-hook))
    ;; Makes everything accept utf-8 as default, so buffers with tsx and so
    ;; won't ask for encoding (because undecided-unix) every single keystroke
    (modify-coding-system-alist 'file "" 'utf-8)
    ;; A Protesilaos life savier HACK
    ;; Add option "d" to whenever using C-x s or C-x C-c, allowing a quick preview
    ;; of the diff (if you choose `d') of what you're asked to save.
    (add-to-list 'save-some-buffers-action-alist
  		       (list "d"
  					 (lambda (buffer) (diff-buffer-with-file (buffer-file-name buffer)))
  					 "show diff between the buffer and its file"))
    ;; On Terminal: changes the vertical separator to a full vertical line
    ;;              and truncation symbol to a right arrow
    (set-display-table-slot standard-display-table 'vertical-border ?\u2502)
    (set-display-table-slot standard-display-table 'truncation ?\u2192)
    ;; Ibuffer filters
    (setq ibuffer-saved-filter-groups
  	    '(("default"
  	       ("org" (or
  				   (mode . org-mode)
  				   (name . "^\\*Org Src")
  				   (name . "^\\*Org Agenda\\*$")))
  	       ("tramp" (name . "^\\*tramp.*"))
  	       ("emacs" (or
  					 (name . "^\\*scratch\\*$")
  					 (name . "^\\*Messages\\*$")
  					 (name . "^\\*Warnings\\*$")
  					 (name . "^\\*Shell Command Output\\*$")
  					 (name . "^\\*Async-native-compile-log\\*$")
  					 (name . "^\\*straight-")))
  	       ("ediff" (or
  					 (name . "^\\*ediff.*")
  					 (name . "^\\*Ediff.*")))
  	       ("dired" (mode . dired-mode))
  	       ("terminal" (or
  						(mode . term-mode)
  						(mode . shell-mode)
  						(mode . eshell-mode)))
  	       ("help" (or
  					(name . "^\\*Help\\*$")
  					(name . "^\\*info\\*$")
  					(name . "^\\*helpful"))))))
    (add-hook 'ibuffer-mode-hook
  			(lambda ()
  		      (ibuffer-switch-to-saved-filter-groups "default")))
    (setq ibuffer-show-empty-filter-groups nil) ; don't show empty groups
    :init
    (set-window-margins (selected-window) 2 0)

    (toggle-frame-maximized)
    (select-frame-set-input-focus (selected-frame))
    (global-auto-revert-mode 1)
    (indent-tabs-mode -1)
    (recentf-mode 1)
    (repeat-mode 1)
    (savehist-mode 1)
    (save-place-mode 1)
    (winner-mode)
    (xterm-mouse-mode 1)
    (file-name-shadow-mode 1) ; allows us to type a new path without having to delete the current one

    (with-current-buffer (get-buffer-create "*scratch*")
      (insert (format ";;
  ;; ███████╗███╗   ███╗ █████╗  ██████╗███████╗
  ;; ██╔════╝████╗ ████║██╔══██╗██╔════╝██╔════╝
  ;; █████╗  ██╔████╔██║███████║██║     ███████╗
  ;; ██╔══╝  ██║╚██╔╝██║██╔══██║██║     ╚════██║
  ;; ███████╗██║ ╚═╝ ██║██║  ██║╚██████╗███████║
  ;; ╚══════╝╚═╝     ╚═╝╚═╝  ╚═╝ ╚═════╝╚══════╝
  ;;   Loading time : %s
  ;;   Packages     : %s
  ;;
  "
  					(emacs-init-time)
  					(number-to-string (length package-activated-list)))))

    (message (emacs-init-time)))
#+END_SRC

** Which-Key
#+BEGIN_SRC elisp
  (use-package which-key
    :defer t
    :ensure nil
    :hook
    (after-init-hook . which-key-mode)
    :config
    (setq which-key-separator "  ")
    (setq which-key-prefix-prefix "... ")
    (setq which-key-max-display-columns 3)
    (setq which-key-idle-delay 1.5)
    (setq which-key-idle-secondary-delay 0.25)
    (setq which-key-add-column-padding 1)
    (setq which-key-max-description-length 40))
#+END_SRC

** Simple Rainbow Delimiters
#+BEGIN_SRC elisp
  ;;; EMACS-SOLO-RAINBOW-DELIMITERS
  ;;
  ;;  Colorizes matching delimiters
  ;;
  ;;  FIXME: Make it play nice with treesitter modes
  ;;
  (use-package emacs-solo-rainbow-delimiters
    :ensure nil
    :no-require t
    :defer t
    :init
    (defun emacs-solo/rainbow-delimiters ()
      "Apply simple rainbow coloring to parentheses, brackets, and braces in the current buffer.
  Opening and closing delimiters will have matching colors."
      (interactive)
      (let ((colors '(font-lock-keyword-face
                      font-lock-type-face
                      font-lock-function-name-face
                      font-lock-variable-name-face
                      font-lock-constant-face
                      font-lock-builtin-face
                      font-lock-string-face
                      )))
        (font-lock-add-keywords
         nil
         `((,(rx (or "(" ")" "[" "]" "{" "}"))
            (0 (let* ((char (char-after (match-beginning 0)))
                      (depth (save-excursion
                               ;; Move to the correct position based on opening/closing delimiter
                               (if (member char '(?\) ?\] ?\}))
                                   (progn
                                     (backward-char) ;; Move to the opening delimiter
                                     (car (syntax-ppss)))
                                 (car (syntax-ppss)))))
                      (face (nth (mod depth ,(length colors)) ',colors)))
                 (list 'face face)))))))
      (font-lock-flush)
      (font-lock-ensure))

    (add-hook 'prog-mode-hook #'emacs-solo/rainbow-delimiters))
#+END_SRC

** Viper Configuration
#+BEGIN_SRC elisp
  (use-package viper
    :ensure nil
    :init
    (setq viper-mode t)
    (setq viper-inhibit-startup-message t)
    (setq viper-expert-level 5)
    (setq viper-want-ctl-h-help t)
    (setq viper-ex-style-editing nil)
    (setq viper-no-multiple-ESC nil)
    (setq viper-syntax-preference 'extended)
    (setq viper-vi-style-in-minibuffer nil)
    (require 'viper))

  ;; from emacs-solo repository
  (use-package emacs-solo-viper-extensions
    :ensure nil
    :no-require t
    :defer t
    :after viper
    :init
    (defun viper-operate-inside-delimiters (open close op)
      "Perform OP inside delimiters OPEN and CLOSE (e.g., (), {}, '', or \"\")."
      (save-excursion
        (search-backward (char-to-string open) nil t)
        (forward-char) ;; Move past the opening delimiter
        (let ((start (point)))
          (search-forward (char-to-string close) nil t)
          (backward-char) ;; Move back before the closing delimiter
          (pulse-momentary-highlight-region start (point))
          (funcall op start (point)))))

    ;; FIXME: works for most common cases, misses (  bla bla (bla) |cursor-here| )
    (defun viper-delete-inside-delimiters (open close)
      "Delete text inside delimiters OPEN and CLOSE, saving it to the kill ring."
      (interactive "cEnter opening delimiter: \ncEnter closing delimiter: ")
      (viper-operate-inside-delimiters open close 'kill-region))

    (defun viper-yank-inside-delimiters (open close)
      "Copy text inside delimiters OPEN and CLOSE to the kill ring."
      (interactive "cEnter opening delimiter: \ncEnter closing delimiter: ")
      (viper-operate-inside-delimiters open close 'kill-ring-save))

    (defun viper-delete-line-or-region ()
      "Delete the current line or the selected region in Viper mode.
        The deleted text is saved to the kill ring."
      (interactive)
      (if (use-region-p)
          ;; If a region is active, delete it
          (progn
        	  (pulse-momentary-highlight-region (region-beginning) (region-end))
        	  (run-at-time 0.1 nil 'kill-region (region-beginning) (region-end)))
        ;; Otherwise, delete the current line including its newline character
        (pulse-momentary-highlight-region (line-beginning-position) (line-beginning-position 2))
        (run-at-time 0.1 nil 'kill-region (line-beginning-position) (line-beginning-position 2))))

    (defun viper-yank-line-or-region ()
      "Yank the current line or the selected region and highlight the region."
      (interactive)
      (if (use-region-p)
        	;; If a region is selected, yank it
        	(progn
            (kill-ring-save (region-beginning) (region-end))  ;; Yank the region
            (pulse-momentary-highlight-region (region-beginning) (region-end)))
        ;; Otherwise, yank the current line
        (let ((start (line-beginning-position))
        		(end (line-end-position)))
        	(kill-ring-save start end)  ;; Yank the current line
        	(pulse-momentary-highlight-region start end))))

    (defun viper-delete-inner-word ()
      "Delete the current word under the cursor, handling edge cases."
      (interactive)
      (let ((bounds (bounds-of-thing-at-point 'word)))
        (if bounds
            (kill-region (car bounds) (cdr bounds))
          (message "No word under cursor"))))

    (defun viper-change-inner-word ()
      "Change the current word under the cursor, handling edge cases."
      (interactive)
      (viper-delete-inner-word)
      (viper-insert nil))

    (defun viper-yank-inner-word ()
      "Yank (copy) the current word under the cursor, handling edge cases."
      (interactive)
      (let ((bounds (bounds-of-thing-at-point 'word)))
        (pulse-momentary-highlight-region (car bounds) (cdr bounds))
        (if bounds
            (kill-ring-save (car bounds) (cdr bounds))
          (message "No word under cursor"))))

    (defun viper-delete-inner-compound-word ()
      "Delete the entire compound word under the cursor, including `-` and `_`."
      (interactive)
      (let ((bounds (viper-compound-word-bounds)))
        (if bounds
            (kill-region (car bounds) (cdr bounds))
          (message "No compound word under cursor"))))

    (defun viper-change-inner-compound-word ()
      "Change the entire compound word under the cursor, including `-` and `_`."
      (interactive)
      (viper-delete-inner-compound-word)
      (viper-insert nil))

    (defun viper-yank-inner-compound-word ()
      "Yank the entire compound word under the cursor into the kill ring."
      (interactive)
      (let ((bounds (viper-compound-word-bounds)))
        (pulse-momentary-highlight-region (car bounds) (cdr bounds))
        (if bounds
            (kill-ring-save (car bounds) (cdr bounds))
          (message "No compound word under cursor"))))

    (defun viper-compound-word-bounds ()
      "Get the bounds of a compound word under the cursor.
      A compound word includes letters, numbers, `-`, and `_`."
      (save-excursion
        (let* ((start (progn
                        (skip-chars-backward "a-zA-Z0-9_-")
                        (point)))
               (end (progn
                      (skip-chars-forward "a-zA-Z0-9_-")
                      (point))))
          (when (< start end) (cons start end)))))

    (defun viper-visual-select-line ()
  	"Start visual selection from the beginning of the current line."
  	(interactive)
  	(set-mark (line-beginning-position)))

    (defun minknavemacs/jump-back-to-mark ()
  	"Interactive function that attempts to move the cursor to the previously set mark."
  	(interactive)
  	(setq current-prefix-arg '(4)) ; C-u
  	(call-interactively 'set-mark-command))


    (defun minknavemacs/org-quick-time-stamp-inactive ()
  	"Insert an inactive time stamp of the current time without user prompt"
  	(interactive)
  	(let ((current-prefix-arg '(16)))
  	  (call-interactively 'org-time-stamp-inactive))
  	(insert " "))

    ;; Delete inside delimiters
    (define-key viper-vi-global-user-map (kbd "di(") (lambda () (interactive) (viper-delete-inside-delimiters ?\( ?\))))
    (define-key viper-vi-global-user-map (kbd "dib") (lambda () (interactive) (viper-delete-inside-delimiters ?\( ?\))))
    (define-key viper-vi-global-user-map (kbd "di{") (lambda () (interactive) (viper-delete-inside-delimiters ?{ ?})))
    (define-key viper-vi-global-user-map (kbd "di\"") (lambda () (interactive) (viper-delete-inside-delimiters ?\" ?\")))
    (define-key viper-vi-global-user-map (kbd "di'") (lambda () (interactive) (viper-delete-inside-delimiters ?' ?')))

    ;; Yank inside delimiters
    (define-key viper-vi-global-user-map (kbd "yi(") (lambda () (interactive) (viper-yank-inside-delimiters ?\( ?\))))
    (define-key viper-vi-global-user-map (kbd "yi{") (lambda () (interactive) (viper-yank-inside-delimiters ?{ ?})))
    (define-key viper-vi-global-user-map (kbd "yi\"") (lambda () (interactive) (viper-yank-inside-delimiters ?\" ?\")))
    (define-key viper-vi-global-user-map (kbd "yi'") (lambda () (interactive) (viper-yank-inside-delimiters ?' ?')))

    ;; Delete/Yank current line or region
    (define-key viper-vi-global-user-map (kbd "dd") 'viper-delete-line-or-region)
    (define-key viper-vi-global-user-map (kbd "yy") 'viper-yank-line-or-region)
    
    ;; Delete/Yank current word
    (define-key viper-vi-global-user-map (kbd "diw") 'viper-delete-inner-word)
    (define-key viper-vi-global-user-map (kbd "yiw") 'viper-yank-inner-word)
    (define-key viper-vi-global-user-map (kbd "ciw") 'viper-change-inner-word)
    (define-key viper-vi-global-user-map (kbd "diW") 'viper-delete-inner-compound-word)
    (define-key viper-vi-global-user-map (kbd "yiW") 'viper-yank-inner-compound-word)
    (define-key viper-vi-global-user-map (kbd "ciW") 'viper-change-inner-compound-word)

    ;; visual select commands 
    (define-key viper-vi-global-user-map (kbd "v") 'set-mark-command)
    (define-key viper-vi-global-user-map (kbd "V") 'viper-visual-select-line)

    ;; Go, Jump, Shift, extended commands
    (define-key viper-vi-global-user-map (kbd "g g") 'keyboard-quit)   
    (define-key viper-vi-global-user-map (kbd "g v") 'minknavemacs/jump-back-to-mark)
    (define-key viper-vi-global-user-map (kbd "g u") 'universal-argument)

    ;; Z Commands, shift views and manage splits
    (define-key viper-vi-global-user-map (kbd "z t") 'viper-line-to-top)
    (define-key viper-vi-global-user-map (kbd "z z") 'viper-line-to-middle)
    (define-key viper-vi-global-user-map (kbd "z b") 'viper-line-to-bottom)
    (define-key viper-vi-global-user-map (kbd "z x") 'delete-other-windows)
    (define-key viper-vi-global-user-map (kbd "z c") 'delete-window)
    (define-key viper-vi-global-user-map (kbd "z s") 'split-window-below)
    (define-key viper-vi-global-user-map (kbd "z v") 'split-window-right)
    (define-key viper-vi-global-user-map (kbd "z h") 'windmove-left)
    (define-key viper-vi-global-user-map (kbd "z j") 'windmove-down)
    (define-key viper-vi-global-user-map (kbd "z k") 'windmove-up)
    (define-key viper-vi-global-user-map (kbd "z l") 'windmove-right)

    ;; "Quick" Menus start with prefix SPC
    (define-key viper-vi-global-user-map (kbd "SPC SPC") 'switch-to-buffer)
    (define-key viper-vi-global-user-map (kbd "SPC k") 'kill-current-buffer)
    (define-key viper-vi-global-user-map (kbd "SPC b k") 'kill-buffer)
    (define-key viper-vi-global-user-map (kbd "SPC b i") 'ibuffer)

    (define-key viper-vi-global-user-map (kbd "SPC o a") 'org-agenda)
    (define-key viper-vi-global-user-map (kbd "SPC o c") 'org-capture)
    (define-key viper-vi-global-user-map (kbd "SPC o l") 'org-store-link)
    (define-key viper-vi-global-user-map (kbd "SPC o t") 'minknavemacs/org-quick-time-stamp-inactive)

    (define-key viper-vi-global-user-map (kbd "SPC x s") 'save-buffer)
    (define-key viper-vi-global-user-map (kbd "SPC x d") 'dired-jump)
    (define-key viper-vi-global-user-map (kbd "SPC x f") 'find-file)
    (define-key viper-vi-global-user-map (kbd "SPC x c") 'save-buffers-kill-terminal))
#+END_SRC

** icomplete Completions
#+BEGIN_SRC elisp
  ;;; ICOMPLETE
  (use-package icomplete
    :bind (:map icomplete-minibuffer-map
                ("C-j" . icomplete-forward-completions)
                ("C-k" . icomplete-backward-completions)
                ("C-v" . icomplete-vertical-toggle)
                ("RET" . icomplete-force-complete-and-exit)
                ("C-c" . exit-minibuffer)) ;; So we can exit commands like `multi-file-replace-regexp-as-diff'
    :hook
    (after-init-hook . (lambda ()
                         (fido-mode -1)
                         (icomplete-vertical-mode 1)))
    :config
    (setq icomplete-delay-completions-threshold 0)
    (setq icomplete-compute-delay 0)
    (setq icomplete-show-matches-on-no-input t)
    (setq icomplete-hide-common-prefix nil)
    (setq icomplete-prospects-height 10)
    (setq icomplete-separator " . ")
    (setq icomplete-with-completion-tables t)
    (setq icomplete-in-buffer t)
    (setq icomplete-max-delay-chars 0)
    (setq icomplete-scroll t)

    ;; EMACS-31
    (when (and (>= emacs-major-version 31)
               (boundp 'icomplete-vertical-in-buffer-adjust-list))

      (setq icomplete-vertical-in-buffer-adjust-list t)
      (setq icomplete-vertical-render-prefix-indicator t)
      ;; (setq icomplete-vertical-selected-prefix-indicator   " @ ")
      ;; (setq icomplete-vertical-unselected-prefix-indicator "   ")
      )

    (if icomplete-in-buffer
        (advice-add 'completion-at-point
                    :after #'minibuffer-hide-completions))

    ;; https://lists.gnu.org/archive/html/bug-gnu-emacs/2025-03/msg02638.html
    ;;
    ;; I'm currently proposing these features on bug#75784 (bug-gnu-emacs).
    ;; If they get accepted we can get rid of this giant block.
    ;;
    ;; === FIXME: I'm reviewing it to the icomplete PATCH

    ;; EMACS-31
    (when (or (< emacs-major-version 31)
              (not (boundp 'icomplete-vertical-in-buffer-adjust-list)))

      (defface icomplete-vertical-selected-prefix-indicator-face
        '((t :inherit font-lock-keyword-face :weight bold :foreground "cyan"))
        "Face used for the prefix set by `icomplete-vertical-selected-prefix-indicator'."
        :group 'icomplete
        :version "31.1")

      (defface icomplete-vertical-unselected-prefix-indicator-face
        '((t :inherit font-lock-keyword-face :weight normal :foreground "gray"))
        "Face used for the prefix set by `icomplete-vertical-unselected-prefix-indicator'."
        :group 'icomplete
        :version "31.1")

      (defcustom icomplete-vertical-in-buffer-adjust-list t
        "Control whether in-buffer completion should align the cursor position.
  If this is t and `icomplete-in-buffer' is t, and `icomplete-vertical-mode'
  is activated, the in-buffer vertical completions are shown aligned to the
  cursor position when the completion started, not on the first column, as
  the default behaviour."
        :type 'boolean
        :group 'icomplete
        :version "31.1")

      (defcustom icomplete-vertical-render-prefix-indicator t
        "Control whether a indicator is added as a prefix to each candidate.
  If this is t and `icomplete-vertical-mode' is activated, a indicator,
  controlled by `icomplete-vertical-selected-prefix-indicator' is shown
  as a prefix to the current under selection candidate, while the
  remaining of the candidates will receive the indicator controlled
  by `icomplete-vertical-unselected-prefix-indicator'."
        :type 'boolean
        :group 'icomplete
        :version "31.1")

      (defcustom icomplete-vertical-selected-prefix-indicator "» "
        "Prefix string used to mark the selected completion candidate.
  If `icomplete-vertical-render-prefix-indicator' is t, the string
  defined here is used as a prefix of the currently selected entry in the
  list.  It can be further customized by the face
  `icomplete-vertical-selected-prefix-indicator-face'."
        :type 'string
        :group 'icomplete
        :version "31.1")

      (defcustom icomplete-vertical-unselected-prefix-indicator "  "
        "Prefix string used on the unselected completion candidates.
  If `icomplete-vertical-render-prefix-indicator' is t, the string
  defined here is used as a prefix for all unselected entries in the list.
  list.  It can be further customized by the face
  `icomplete-vertical-unselected-prefix-indicator-face'."
        :type 'string
        :group 'icomplete
        :version "31.1")

      ;; FIXME: make this into PATCH - OK
      (defun icomplete-vertical--adjust-lines-for-column (lines buffer data)
        "Adjust the LINES to align with the column in BUFFER based on DATA."
        (if icomplete-vertical-in-buffer-adjust-list
            (let* ((column (current-column))
                   (prefix-indicator-width
                    (if icomplete-vertical-render-prefix-indicator
                        (max (length icomplete-vertical-selected-prefix-indicator)
                             (length icomplete-vertical-unselected-prefix-indicator))
                      0))
                   (wrapped-line (with-current-buffer buffer
                                   (save-excursion
                                     (goto-char (car data))
                                     (beginning-of-line)
                                     (count-screen-lines (point) (car data)))))
                   (window-width (+ (window-hscroll) (window-body-width)))
                   (longest-line-width (apply #'max (mapcar #'length lines)))
                   (spaces-to-add
                    (if (> wrapped-line 1)
                        (- column (* (- wrapped-line 1) (- window-width 5)))
                      column))
                   (spaces-to-add-avoiding-scrolling
                    (if (>= (+ spaces-to-add longest-line-width prefix-indicator-width) window-width)
                        (- spaces-to-add longest-line-width)
                      spaces-to-add)))

              (mapcar (lambda (line)
                        (concat (make-string spaces-to-add-avoiding-scrolling ?\s) line))
                      lines))
          lines))

      ;; FIXME: what to demo/test:
      ;;
      ;; This patch provides two more new features, which improves icomplete-vertical-mode, 1 and 2,
      ;; explained below:
      ;;
      ;;
      ;; 1.) Improve feature provided by `icomplete-in-buffer'.
      ;;     If user, besides setting `icomplete-in-buffer' to t, also set the
      ;;     new `icomplete-vertical-in-buffer-adjust-list' to t, the following are fixed/ improved:
      ;;
      ;; Without the new `icomplete-vertical-in-buffer-adjust-list':
      ;; - [ ] wrapped lines   - completion candidates on different columns always shows candidates at column 0
      ;; - [ ] wrapped lines   - completion candidates on different lines always shows candidates at column 0
      ;; - [ ] wrapped lines   - completion candidates close to the end of buffer won't be printed
      ;; - [ ] truncated lines - completion candidates on different columns always shows candidates at column 0
      ;; - [ ] truncated lines - completion candidates on horizontally scrolled windows won't appear on buffer
      ;;                         as they're on column 0
      ;; - [ ] truncated lines - completion candidates close to the end of buffer wont be shown
      ;;
      ;;
      ;; With the new `icomplete-vertical-in-buffer-adjust-list':
      ;; - [ ] wrapped lines   - fix    : completion candidates on different columns will always be printed
      ;;                                  under the cursor
      ;; - [ ] wrapped lines   - feature: completion candidates on different columns close to the end
      ;;                                  of the buffer will adjust so they stay visible
      ;; - [ ] wrapped lines   - fix:   : completion candidates on different lines always be printed under
      ;;                                  the cursor
      ;; - [ ] wrapped lines   - fix    : if icomplete-prospects-height won't fit from current line to the
      ;;                                  end of vertical space, our window will be scrolled so we have at
      ;;                                  least this amount of lines. This ensures our candidates list is
      ;;                                  always visible
      ;; - [ ] truncated lines - fix    : completion candidates on different columns will always be printed
      ;;                                  under the cursor
      ;; - [ ] truncated lines - feature: completion candidates on different columns close to the end
      ;;                                  of the buffer will adjust so they stay visible even when we scroll
      ;;                                  horizontally
      ;; - [ ] truncated lines - feature: completion candidates on horizontally scrolled windows will be
      ;;                                  printed under the cursor
      ;; - [ ] wrapped lines   - feature: if icomplete-prospects-height won't fit from current line to the
      ;;                                  end of vertical space, our window will be scrolled so we have at
      ;;                                  least this amount of lines. This ensures our candidates list is
      ;;                                  always visible
      ;; - [ ] from wrapped    - feature: if we are on wrapped lines and manually horiontal scroll, the lines
      ;;       to truncated               will become automatically truncated, in this case, all the features
      ;;                                  above still works from either mode (wrapped or truncated).
      ;;
      ;;
      ;; 2.) Implements new feature which provides customizable prefix indicators
      ;;
      ;; Setting `icomplete-vertical-render-prefix-indicator' to t will provide a prefix indicator
      ;; to indicate the current selected candidate, by default "» ".
      ;;
      ;; This prefix is customizable through the variable `icomplete-vertical-selected-prefix-indicator'
      ;; and de face `icomplete-vertical-selected-prefix-indicator-face'.
      ;;
      ;; Users can also customize an indicator to the not selected candidates trhough the use of
      ;; the variable `icomplete-vertical-unselected-prefix-indicator', by default: "  ", and the face
      ;; `icomplete-vertical-unselected-prefix-indicator-face'.
      ;;


      ;; FIXME: remove this after patch
      (defun icomplete-vertical--ensure-visible-lines-inside-buffer ()
        "Ensure the completion list is visible in regular buffers only.
  Scrolls the screen to be at least `icomplete-prospects-height' real lines
  away from the bottom.  Counts wrapped lines as real lines."
        (unless (minibufferp)
          (let* ((window-height (window-body-height))
                 (current-line (count-screen-lines (window-start) (point)))
                 (lines-to-bottom (- window-height current-line)))
            (when (< lines-to-bottom icomplete-prospects-height)
              (scroll-up (- icomplete-prospects-height lines-to-bottom))))))


      (defun icomplete-vertical--add-indicator-to-selected (comp)
        "Add indicators to the selected/unselected COMP completions."
        (if (and icomplete-vertical-render-prefix-indicator
                 (get-text-property 0 'icomplete-selected comp))
            (concat (propertize icomplete-vertical-selected-prefix-indicator
                                'face 'icomplete-vertical-selected-prefix-indicator-face)
                    comp)
          (concat (propertize icomplete-vertical-unselected-prefix-indicator
                              'face 'icomplete-vertical-unselected-prefix-indicator-face)
                  comp)))


      (cl-defun icomplete--render-vertical
          (comps md &aux scroll-above scroll-below
                 (total-space ; number of mini-window lines available
                  (1- (min
                       icomplete-prospects-height
                       (truncate (max-mini-window-lines) 1)))))
        ;; Welcome to loopapalooza!
        ;;
        ;; First, be mindful of `icomplete-scroll' and manual scrolls.  If
        ;; `icomplete--scrolled-completions' and `icomplete--scrolled-past'
        ;; are:
        ;;
        ;; - both nil, there is no manual scroll;
        ;; - both non-nil, there is a healthy manual scroll that doesn't need
        ;;   to be readjusted (user just moved around the minibuffer, for
        ;;   example);
        ;; - non-nil and nil, respectively, a refiltering took place and we
        ;;   may need to readjust them to the new filtered `comps'.
        (when (and icomplete-scroll                                    ;; FIXME: remove this after patch
                   (not icomplete--scrolled-completions)
                   (not icomplete--scrolled-past))
          (icomplete-vertical--ensure-visible-lines-inside-buffer))
        (when (and icomplete-scroll
                   icomplete--scrolled-completions
                   (null icomplete--scrolled-past))
          (icomplete-vertical--ensure-visible-lines-inside-buffer)     ;; FIXME: remove this after patch
          (cl-loop with preds
                   for (comp . rest) on comps
                   when (equal comp (car icomplete--scrolled-completions))
                   do
                   (setq icomplete--scrolled-past preds
                         comps (cons comp rest))
                   (completion--cache-all-sorted-completions
                    (icomplete--field-beg)
                    (icomplete--field-end)
                    comps)
                   and return nil
                   do (push comp preds)
                   finally (setq icomplete--scrolled-completions nil)))
        ;; Then, in this pretty ugly loop, collect completions to display
        ;; above and below the selected one, considering scrolling
        ;; positions.
        (cl-loop with preds = icomplete--scrolled-past
                 with succs = (cdr comps)
                 with space-above = (- total-space
                                       1
                                       (cl-loop for (_ . r) on comps
                                                repeat (truncate total-space 2)
                                                while (listp r)
                                                count 1))
                 repeat total-space
                 for neighbor = nil
                 if (and preds (> space-above 0)) do
                 (push (setq neighbor (pop preds)) scroll-above)
                 (cl-decf space-above)
                 else if (consp succs) collect
                 (setq neighbor (pop succs)) into scroll-below-aux
                 while neighbor
                 finally (setq scroll-below scroll-below-aux))
        ;; Halfway there...
        (let* ((selected (propertize (car comps) 'icomplete-selected t))
               (chosen (append scroll-above (list selected) scroll-below))
               (tuples (icomplete--augment md chosen))
               max-prefix-len max-comp-len lines nsections)
          (add-face-text-property 0 (length selected)
                                  'icomplete-selected-match 'append selected)
          ;; Figure out parameters for horizontal spacing
          (cl-loop
           for (comp prefix) in tuples
           maximizing (length prefix) into max-prefix-len-aux
           maximizing (length comp) into max-comp-len-aux
           finally (setq max-prefix-len max-prefix-len-aux
                         max-comp-len max-comp-len-aux))
          ;; Serialize completions and section titles into a list
          ;; of lines to render
          (cl-loop
           for (comp prefix suffix section) in tuples
           when section
           collect (propertize section 'face 'icomplete-section) into lines-aux
           and count 1 into nsections-aux
           for comp = (icomplete-vertical--add-indicator-to-selected comp)
           when (get-text-property 0 'icomplete-selected comp)
           do (add-face-text-property 0 (length comp)
                                      'icomplete-selected-match 'append comp)
           collect (concat prefix
                           (make-string (max 0 (- max-prefix-len (length prefix))) ? )
                           (completion-lazy-hilit comp)
                           (make-string (max 0 (- max-comp-len (length comp))) ? )
                           suffix)
           into lines-aux
           finally (setq lines lines-aux
                         nsections nsections-aux))
          ;; Kick out some lines from the beginning due to extra sections.
          ;; This hopes to keep the selected entry more or less in the
          ;; middle of the dropdown-like widget when `icomplete-scroll' is
          ;; t.  Funky, but at least I didn't use `cl-loop'
          (setq lines
                (nthcdr
                 (cond ((<= (length lines) total-space) 0)
                       ((> (length scroll-above) (length scroll-below)) nsections)
                       (t (min (ceiling nsections 2) (length scroll-above))))
                 lines))
          (when icomplete--in-region-buffer
            (setq lines (icomplete-vertical--adjust-lines-for-column
                         lines icomplete--in-region-buffer completion-in-region--data)))
          ;; At long last, render final string return value.  This may still
          ;; kick out lines at the end.
          (concat " \n"
                  (cl-loop for l in lines repeat total-space concat l concat "\n")))))

    ;; end use-package
    )
#+END_SRC
