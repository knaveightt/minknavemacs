* What Is This
A mashup of my current knavemacs configuration, snippets from SystemCrafters,
and a lot of copy-paste from LionyxML's emacs-solo configuration.  The goal is
to minimize the number of external packages I pull into emacs while providing a
fully-fledged emacs configuration to taste.

This also includes a custom modal editing scheme I created leveraging
ryo-modal which I hope to make more formal in the future as well.

All that should be needed to run this configuration is the following
in the init.el file (although I include a sample init.el file in this
repository as well):

: (require 'org)
: (require 'ob-tangle)
: (org-babel-load-file "~/.config/emacs/minknavemacs.org")

* Prerequsites
- ripgrep installed
- JetBrainsMono Nerd Font is installed
- move 'snippets' folder to ~/Documents/data/snippets
- ensure 'modal' folder is in ~/.config/emacs/
- Create the following under ~/Documents/org/
  - notice.org
  - ticker.org
  - inbox.org
  - backlog.org
  - workstreams/ 
- run M-x nerd-icons-install-fonts once

* Configuration
** General Configuration
*** Early Init
Gracefully picked up from https://github.com/LionyxML/emacs-solo

*** Emacs General Config
#+BEGIN_SRC elisp
      (use-package emacs
        :ensure nil
        :custom
        (ad-redefinition-action 'accept)
        (column-number-mode nil)
        (line-number-mode nil)
        (completion-ignore-case t)
        (completions-detailed t)
        (delete-by-moving-to-trash t)
        (display-line-numbers-width 3)
        (display-line-numbers-widen t)
        (delete-selection-mode 1)
        (enable-recursive minibuffers t)
        (find-ls-option '("-exec ls -ldh {} +" . "-ldh"))  ; find-dired results with human readable sizes
        (frame-resize-pixelwise t)
        (global-auto-revert-non-file-buffers t)
        (help-window-select t)
        (history-length 300)
        (inhibit-startup-message t)
        (initial-scratch-message "")
        (ispell-dictionary "en_US")
        (kill-do-not-save-duplicates t)
        (create-lockfiles nil)   ; No backup files
        (make-backup-files nil)  ; No backup files
        (backup-inhibited t)     ; No backup files
        (pixel-scroll-precision-mode t)
        (pixel-scroll-precision-use-momentum nil)
        (ring-bell-function 'ignore)
        (read-answer-short t)
        (recentf-max-saved-items 300) ; default is 20
        (recentf-max-menu-items 15)
        (recentf-auto-cleanup (if (daemonp) 300 'never))
        (recentf-exclude (list "^/\\(?:ssh\\|su\\|sudo\\)?:"))
        (remote-file-name-inhibit-delete-by-moving-to-trash t)
        (remote-file-name-inhibit-auto-save t)
        (resize-mini-windows 'grow-only)
        (ring-bell-function #'ignore)
        (scroll-conservatively 8)
        (scroll-margin 0)
        (savehist-save-minibuffer-history t)    ; t is default
        (savehist-additional-variables
         '(kill-ring                            ; clipboard
           register-alist                       ; macros
           mark-ring global-mark-ring           ; marks
           search-ring regexp-search-ring))     ; searches
        (save-place-file (expand-file-name "saveplace" user-emacs-directory))
        (save-place-limit 600)
        (set-mark-command-repeat-pop t) ; So we can use C-u C-SPC C-SPC C-SPC... instead of C-u C-SPC C-u C-SPC...
        (split-width-threshold 170)     ; So vertical splits are preferred
        (split-height-threshold nil)
        (shr-use-colors nil)
        (switch-to-buffer-obey-display-actions t)
        (tab-always-indent 'complete)
        (tab-width 4)
  	    (c-basic-offset 4)
        (treesit-font-lock-level 4)
        (truncate-lines t)
        (undo-limit (* 13 160000))
        (undo-strong-limit (* 13 240000))
        (undo-outer-limit (* 13 24000000))
        (use-dialog-box nil)
        (use-file-dialog nil)
        (use-package-hook-name-suffix nil)
        (use-short-answers t)
        (visible-bell nil)
        (window-combination-resize t)
        (window-resize-pixelwise nil)
        (xref-search-program 'ripgrep)
        (grep-command "rg -nS --no-heading ")
        (grep-find-ignored-directories
         '("SCCS" "RCS" "CVS" "MCVS" ".src" ".svn" ".git" ".hg" ".bzr" "_MTN" "_darcs" "{arch}" "node_modules" "build" "dist"))
        :config
        ;; Font and Theme Configuration
        (load-theme 'modus-vivendi-tinted t)
        (add-to-list 'default-frame-alist
          		   '(font . "JetBrainsMono NF 12"))
        ;; Set line-number-mode with relative numbering
        (defun minknavemacs/no-line-nums-hook ()
          (display-line-numbers-mode 0))
        (setq display-line-numbers-type 'relative)
        (global-display-line-numbers-mode t)
        (dolist (mode '(term-mode-hook
          			  eshell-mode-hook
          			  dired-mode-hook))
          (add-hook mode 'minknavemacs/no-line-nums-hook))
        ;; Makes everything accept utf-8 as default, so buffers with tsx and so
        ;; won't ask for encoding (because undecided-unix) every single keystroke
        (modify-coding-system-alist 'file "" 'utf-8)
        ;; A Protesilaos life savier HACK
        ;; Add option "d" to whenever using C-x s or C-x C-c, allowing a quick preview
        ;; of the diff (if you choose `d') of what you're asked to save.
        (add-to-list 'save-some-buffers-action-alist
          		   (list "d"
          				 (lambda (buffer) (diff-buffer-with-file (buffer-file-name buffer)))
          				 "show diff between the buffer and its file"))
        ;; On Terminal: changes the vertical separator to a full vertical line
        ;;              and truncation symbol to a right arrow
        (set-display-table-slot standard-display-table 'vertical-border ?\u2502)
        (set-display-table-slot standard-display-table 'truncation ?\u2192)
        ;; Ibuffer filters
        (setq ibuffer-saved-filter-groups
          	'(("default"
          	   ("org" (or
          			   (mode . org-mode)
          			   (name . "^\\*Org Src")
          			   (name . "^\\*Org Agenda\\*$")))
          	   ("tramp" (name . "^\\*tramp.*"))
          	   ("emacs" (or
          				 (name . "^\\*scratch\\*$")
          				 (name . "^\\*Messages\\*$")
          				 (name . "^\\*Warnings\\*$")
          				 (name . "^\\*Shell Command Output\\*$")
          				 (name . "^\\*Async-native-compile-log\\*$")
          				 (name . "^\\*straight-")))
          	   ("ediff" (or
          				 (name . "^\\*ediff.*")
          				 (name . "^\\*Ediff.*")))
          	   ("dired" (mode . dired-mode))
          	   ("terminal" (or
          					(mode . term-mode)
          					(mode . shell-mode)
          					(mode . eshell-mode)))
          	   ("help" (or
          				(name . "^\\*Help\\*$")
          				(name . "^\\*info\\*$")
          				(name . "^\\*helpful"))))))
        (add-hook 'ibuffer-mode-hook
          		(lambda ()
          		  (ibuffer-switch-to-saved-filter-groups "default")))
        (setq ibuffer-show-empty-filter-groups nil) ; don't show empty groups
        :init
        (set-window-margins (selected-window) 2 0)

        (toggle-frame-maximized)
        (select-frame-set-input-focus (selected-frame))
        (global-auto-revert-mode 1)
        (indent-tabs-mode -1)
  	    (electric-pair-mode 1)
        (recentf-mode 1)
        (repeat-mode 1)
        (savehist-mode 1)
        (save-place-mode 1)
        (winner-mode)
        (xterm-mouse-mode 1)
        (file-name-shadow-mode 1) ; allows us to type a new path without having to delete the current one

        (with-current-buffer (get-buffer-create "*scratch*")
          (insert (format ";;
  ;; ▄▄▄▄  ▄ ▄▄▄▄  ██╗  ██╗███╗   ██╗ █████╗ ██╗   ██╗███████╗███╗   ███╗ █████╗  ██████╗███████╗
  ;; █ █ █ ▄ █   █ ██║ ██╔╝████╗  ██║██╔══██╗██║   ██║██╔════╝████╗ ████║██╔══██╗██╔════╝██╔════╝
  ;; █   █ █ █   █ █████╔╝ ██╔██╗ ██║███████║██║   ██║█████╗  ██╔████╔██║███████║██║     ███████╗
  ;;       █       ██╔═██╗ ██║╚██╗██║██╔══██║╚██╗ ██╔╝██╔══╝  ██║╚██╔╝██║██╔══██║██║     ╚════██║
  ;;               ██║  ██╗██║ ╚████║██║  ██║ ╚████╔╝ ███████╗██║ ╚═╝ ██║██║  ██║╚██████╗███████║
  ;;               ╚═╝  ╚═╝╚═╝  ╚═══╝╚═╝  ╚═╝  ╚═══╝  ╚══════╝╚═╝     ╚═╝╚═╝  ╚═╝ ╚═════╝╚══════╝
  ;;   Loading time : %s
  ;;   Packages     : %s
  ;;
  "
          				(emacs-init-time)
          				(number-to-string (length package-activated-list)))))

        (message (emacs-init-time)))
#+END_SRC

*** Compiling General Config
#+BEGIN_SRC elisp
(use-package compile
  :ensure nil
  :custom
  (compilation-always-kill t)
  (compilation-scroll-output t)
  (ansi-color-for-compilation-mode t)
  :config
  ;; Not ideal, but I do not want this poluting the mode-line
  (defun emacs-solo/ignore-compilation-status (&rest _)
    (setq compilation-in-progress nil))
  (advice-add 'compilation-start :after #'emacs-solo/ignore-compilation-status)

  (add-hook 'compilation-filter-hook #'ansi-color-compilation-filter))
#+END_SRC

*** Window Management
#+BEGIN_SRC elisp
  (use-package window
    :ensure nil
    :custom
    (display-buffer-alist
     '(
       ("\\*container\\*"
        (display-buffer-in-side-window)
        (window-width . 120)
        (side . left)
        (slot . -1))
       ("\\*\\(Backtrace\\|Warnings\\|Compile-Log\\|Messages\\|Bookmark List\\|Occur\\|eldoc\\)\\*"
        (display-buffer-in-side-window)
        (window-height . 0.25)
        (side . bottom)
        (slot . 0))
       ("\\*\\([Hh]elp\\)\\*"
        (display-buffer-in-side-window)
        (window-width . 75)
        (side . right)
        (slot . 0))
       ("\\*\\(Ibuffer\\)\\*"
        (display-buffer-in-side-window)
        (window-width . 100)
        (side . right)
        (slot . 1))
       ("\\*\\(Flymake diagnostics\\|xref\\|Completions\\)"
        (display-buffer-in-side-window)
        (window-height . 0.25)
        (side . bottom)
        (slot . 1))
       ("\\*\\(grep\\|find\\)\\*"
        (display-buffer-in-side-window)
        (window-height . 0.25)
        (side . bottom)
        (slot . 2))
       )))
#+END_SRC

** Visual Configuration
*** Which-Key
#+BEGIN_SRC elisp
  (use-package which-key
    :defer t
    :ensure nil
    :hook
    (after-init-hook . which-key-mode)
    :config
    (setq which-key-separator "  ")
    (setq which-key-prefix-prefix "... ")
    (setq which-key-max-display-columns 3)
    (setq which-key-idle-delay 1.5)
    (setq which-key-idle-secondary-delay 0.25)
    (setq which-key-add-column-padding 1)
    (setq which-key-max-description-length 40))
#+END_SRC

*** Simple Rainbow Delimiters
#+BEGIN_SRC elisp
  ;;; EMACS-SOLO-RAINBOW-DELIMITERS
  ;;
  ;;  Colorizes matching delimiters
  ;;
  ;;  FIXME: Make it play nice with treesitter modes
  ;;
  (use-package emacs-solo-rainbow-delimiters
    :ensure nil
    :no-require t
    :defer t
    :init
    (defun emacs-solo/rainbow-delimiters ()
      "Apply simple rainbow coloring to parentheses, brackets, and braces in the current buffer.
  Opening and closing delimiters will have matching colors."
      (interactive)
      (let ((colors '(font-lock-keyword-face
                      font-lock-type-face
                      font-lock-function-name-face
                      font-lock-variable-name-face
                      font-lock-constant-face
                      font-lock-builtin-face
                      font-lock-string-face
                      )))
        (font-lock-add-keywords
         nil
         `((,(rx (or "(" ")" "[" "]" "{" "}"))
            (0 (let* ((char (char-after (match-beginning 0)))
                      (depth (save-excursion
                               ;; Move to the correct position based on opening/closing delimiter
                               (if (member char '(?\) ?\] ?\}))
                                   (progn
                                     (backward-char) ;; Move to the opening delimiter
                                     (car (syntax-ppss)))
                                 (car (syntax-ppss)))))
                      (face (nth (mod depth ,(length colors)) ',colors)))
                 (list 'face face)))))))
      (font-lock-flush)
      (font-lock-ensure))

    (add-hook 'prog-mode-hook #'emacs-solo/rainbow-delimiters))
#+END_SRC

*** Mode Line Configuration
#+BEGIN_SRC elisp
  (use-package minknavemacs-mode-line
    :ensure nil
    :no-require t
    :defer t
    :init
    ;; ------------MODELINE FACES
    (defface minknavemacs/modeline-faces-modal
    	'((t :foreground "#cccccc"
    		 ))
    	"Default Face"
    	:group 'minknavemacs/mode-line-faces)
    
    (defface minknavemacs/modeline-faces-readonly
    	'((t :foreground "#cccccc"
    		 ))
    	"Default Face"
    	:group 'minknavemacs/mode-line-faces)

    
    (defface minknavemacs/modeline-faces-modified
    	'((t :foreground "#cccccc"
    		 ))
    	"Default Face"
    	:group 'minknavemacs/mode-line-faces)

    (defface minknavemacs/modeline-faces-kmacrorec
    	'((t :foreground "#cccccc"
    		 ))
    	"Default Face"
    	:group 'minknavemacs/mode-line-faces)
    
    ;; ------------MODELINE MODULES

    ;; modeline module: modal indicator
    (defvar-local minknavemacs/modeline-modal-indicator
    	  '(:eval
    		(when (mode-line-window-selected-p)
    		  (propertize (minknavemacs/return-modal-state) 'face 'minknavemacs/modeline-faces-modal)))
    	"Modeline module to show modal / Emacs state indicator.")

    ;; modeline module: readonly indicator
    (defvar-local minknavemacs/modeline-readonly-indicator
        '(:eval
    		(when buffer-read-only
            (propertize "" 'face 'minknavemacs/modeline-faces-readonly)))
    	"Modeline module to provide a readonly indicator for appropriate buffers")

    ;; modeline module: modified indicator
    (defvar-local minknavemacs/modeline-modified-indicator
        '(:eval
    		(when (buffer-modified-p)
            (propertize "" 'face 'minknavemacs/modeline-faces-modified)))
    	"Modeline module to provide a modified indicator for appropriate buffers")

    ;; modeline module: buffer name
    (defvar-local minknavemacs/modeline-bufname
    	  '(:eval
    		(propertize (buffer-name) 'help-echo (buffer-file-name)))
    	"Modeline module to provide the buffer name.")

    ;; modeline module: major mode icon
    (defvar-local minknavemacs/modeline-major-mode-icon
        '(:eval
  		(when (mode-line-window-selected-p)
            (nerd-icons-icon-for-mode major-mode)))
  	"Modeline module to provide an icon based on the major mode.")

    ;; modeline module: major mode name
    (defvar-local minknavemacs/modeline-major-mode-name
      '(:eval
        (when (mode-line-window-selected-p)
          mode-name))
    "Modeline module to provide major mode name.")

    ;; modeline module: right display
    (defvar-local minknavemacs/modeline-right-display
    	  '(""
    		" L%l:C%c "
    		"[%p]")
    	"Modeline module ot provide minimal modeline info aligned right.")

    ;; modeline module: kmacro record indicator
    (defvar-local minknavemacs/modeline-kmacro-indicator
    	  '(:eval
    		(when defining-kbd-macro
            (propertize " (󰑋 MACRO)" 'face 'minknavemacs/modeline-faces-kmacrorec)))
    	"Modeline module to provide an indicator for when recording kmacros")

    
    ;; ------------MODELINE PREPARE VARIABLES
    (dolist (construct '(minknavemacs/modeline-modal-indicator
  					   minknavemacs/modeline-readonly-indicator
    					   minknavemacs/modeline-modified-indicator
    					   minknavemacs/modeline-bufname
  					   minknavemacs/modeline-major-mode-icon
  					   minknavemacs/modeline-major-mode-name
    					   minknavemacs/modeline-right-display
    					   minknavemacs/modeline-kmacro-indicator))
    	(put construct 'risky-local-variable t)) ;; required for modeline local vars
    

    ;; ------------MODELINE FUNCTIONS
    (defun minknavemacs/modeline-fill-for-alignment ()
    	"Modeline module to provide filler space until right-aligned items are added to modeline."
    	(let ((r-length (length (concat (format-mode-line minknavemacs/modeline-right-display) (format-mode-line minknavemacs/modeline-kmacro-indicator)) )))
        (propertize " "
                    'display `(space :align-to (- right ,r-length)))))
    
    (defun minknavemacs/return-modal-state ()
  	"Returns the current viper state, or a default string if void."
  	(interactive)
  	(if ryo-modal-mode
  		(setq modal-mode-string "MODAL")
  	  (setq modal-mode-string "EMACS"))
  	  (format-mode-line 'modal-mode-string))


    ;; ------------MODELINE CONSTRUCTION
    (setq-default mode-line-format
    				'("%e"
    				  " "
    				  minknavemacs/modeline-modal-indicator
    				  mode-line-front-space
    				  minknavemacs/modeline-readonly-indicator
    				  " "
    				  minknavemacs/modeline-modified-indicator
    				  " "
    				  minknavemacs/modeline-bufname
    				  " "
    				  minknavemacs/modeline-major-mode-icon
    				  " "
    				  minknavemacs/modeline-major-mode-name
    				  (:eval (minknavemacs/modeline-fill-for-alignment))
    				  minknavemacs/modeline-right-display
    				  minknavemacs/modeline-kmacro-indicator))
    )
#+END_SRC

** Function Specific Configurations
*** Org Mode Configuration
#+BEGIN_SRC elisp
  (use-package org
    :config
    (setf (cdr (rassoc 'find-file-other-window org-link-frame-setup)) 'find-file) ; open links in same buffer
    (setq org-agenda-files (list "~/Documents/org" "~/Documents/org/workstreams"))
    (setq org-agenda-todo-list-sublevels nil) ;; only want to see top level TODOs in global list
    (setq org-stuck-projects '("+TODO=\"ACTION\"" ("NEXT")))
    (setq org-refile-targets '((org-agenda-files :level . 1)))
    (setq org-todo-keywords
          '((sequence "BACKLOG(b)" "TODO(t)" "ACTION(a)" "NEXT(x)" "FOLLOWUP(w@)" "|" "DONE(d!)" "CANCELLED(c)")
            (sequence "NOTICE(n)" "|" "RESOLVED(r@)")
            ))
    (setq org-todo-keywoard-faces
          '(("TODO" . "green")
            ("BACKLOG" . "red")
            ("ACTION" . "purple")
            ("NEXT" . "green")
            ("FOLLOWUP" . "yellow")
            ("DONE" . "blue")
            ("CANCELLED" . "blue")
            ("NOTICE" . org-warning)
            ("RESOLVED" . "green")
            ))

    ;; custom agenda views
    (setq org-agenda-custom-commands
          '(
            ("d" "Todo Dashboard"
             (
              (todo "NOTICE" ((org-agenda-overriding-header "Today's Notices")))
              (agenda "" ((org-deadline-warning-days 7)))
              (tags "-@step+TODO=\"TODO\"-SCHEDULED={.+}|+@step+TODO=\"NEXT\"-SCHEDULED={.+}"
                    ((org-agenda-overriding-header "This Week's TODOs")))
              (stuck "" ((org-agenda-overriding-header "Stuck Actions")))
              (tags "+TODO=\"FOLLOWUP\"-SCHEDULED={.+}" ((org-agenda-overriding-header "Requires Follow Up")))
              ))
            ))

    ;; org function for printing out a quick timestamp
    (defun minknavemacs/org-quick-time-stamp-inactive ()
  	"Insert an inactive time stamp of the current time without user prompt"
  	(interactive)
  	(let ((current-prefix-arg '(16)))
  	  (call-interactively 'org-time-stamp-inactive))
  	(insert " "))

    ;; capture templates
    (setq org-capture-templates
          '(
            ("n" "Post Notice" entry (file+olp "~/Documents/org/notice.org" "Notices")
             "* NOTICE %?\n- %U Notice Created" :empty-lines 1)

            ("t" "New Todo" entry (file+olp "~/Documents/org/inbox.org" "TODOs")
             "* TODO %i%?")

            ("T" "New Scheduled Todo" entry (file+olp "~/Documents/org/tickler.org" "Scheduled TODOs")
             "* TODO %i%?")

            ("m" "Meeting Notes" entry (file+olp "~/Documents/org/inbox.org" "Meeting Notes")
             "* %t %^{Enter Meeting Title}\n** Attendees\n*** \n** Notes\n*** \n** Action Items\n*** TODO " :tree-type week :clock-in t :clock-resume t :empty-lines 0)
            ))
    (add-hook 'org-mode-hook 'org-indent-mode)
    )
#+END_SRC

*** Tab Bar Mode Configuration
#+BEGIN_SRC elisp
  (use-package tab-bar
    :ensure nil
    :defer t
    :custom
    (tab-bar-close-button-show nil)
    (tab-bar-new-button-show nil)
    (tab-bar-tab-hints t)
    (tab-bar-auto-width t)
    (tab-bar-auto-width-min '(10 4))
    (tab-bar-auto-width-max '(50 5))
    :init
    ;; HACK this is an override of the internal function so it
    ;;      shows only the hint number with some decoration.
    (defun tab-bar-tab-name-format-hints (name _tab i)
      "Show absolute numbers on tabs in the tab bar before the tab name.
  It has effect when `tab-bar-tab-hints' is non-nil."
      (if tab-bar-tab-hints (concat (format " »%d«" i) "") name)))
#+END_SRC

*** Tab Line Mode Configuration
#+BEGIN_SRC emacs-lisp
  (use-package tab-line
    :ensure nil
    :defer t
    :custom
  ;; manually installed elisp script
  ;; Define the function to be used for tab-line management and
  ;; create the buffer list that will be used for holding the tab buffers
  (setq tab-line-tabs-function 'knavemacs/tab-line-buffers)
  (setq knavemacs/tab-line-buffers-list (list (current-buffer)))
  (defun knavemacs/tab-line-buffers ()
    "Provides a list containing buffers to be shown on the tab line"
    knavemacs/tab-line-buffers-list)

  ;; function to add a new tab for a buffer
  (defun knavemacs/tab-line-add-current-buffer ()
    "Adds the current buffer to the list of tabs."
    (interactive)
    (if
        (and
         (not (seq-contains-p knavemacs/tab-line-buffers-list (current-buffer))) ; exclude already added
         (not (string-match (rx "magit") (buffer-name (current-buffer)))) ;; exclude magit buffers
         (not (string-match (rx "COMMIT_EDITMSG") (buffer-name (current-buffer)))) ;; exclude COMMIT buffers
         (not (string-match (rx "CAPTURE-") (buffer-name (current-buffer)))) ;; exclude capture buffers
         (not (string-match (rx "*org-roam*") (buffer-name (current-buffer)))) ;; exclude org-roam buffers
         (not (string-match (rx "*scratch*") (buffer-name (current-buffer)))) ;; exclude *scratch*
         (not (string-match (rx "*Messages*") (buffer-name (current-buffer)))) ;; exclude *Messages*
         (not (string-match (rx "*Mini") (buffer-name (current-buffer)))) ;; exclude mini buffer completions
         (not (string-match (rx "*dashboard*") (buffer-name (current-buffer)))) ;; exclude *dashboard*
         (not (string-match (rx "*eldoc") (buffer-name (current-buffer)))) ;; exclude eldoc buffers
         (not (string-match (rx ".org") (buffer-name (current-buffer)))) ;; exclude org files
         (not (string-match (rx "*Dired") (buffer-name (current-buffer)))) ;; exclude other dired buffers
         (not (string-match (rx "*Completions") (buffer-name (current-buffer)))) ;; exclude completion buffers
         )
        (setq knavemacs/tab-line-buffers-list (append knavemacs/tab-line-buffers-list (list (current-buffer)))))

                                          ; buffer must have a buffer name. Some dired or other system buffers do not have a name, so filter those out
    (setq knavemacs/tab-line-buffers-list (seq-remove (lambda (elt) (not (buffer-name elt))) knavemacs/tab-line-buffers-list)) 
    (set-window-parameter nil 'tab-line-cache nil)
    (force-mode-line-update))

  ;; this function is not called directly, but helps in removing tabs
  (defun knavemacs/tab-line-switch-before-drop-kill ()
    "Switch to another tab, before dropping/killing current buffer (to prevent backgrounded buffers unexpectedly returning to knavemacs/tab-line-buffers-list)."
    (let ((n (seq-position knavemacs/tab-line-buffers-list (current-buffer))))
      (cond
       ((= (length knavemacs/tab-line-buffers-list) 1)
        ;;If only one tab, return error
        (message "Only one tab open, cannot drop"))
       ;;If left most tab, switch right
       ((= n 0)
        (switch-to-buffer (nth 1 knavemacs/tab-line-buffers-list)))
       ;;otherwise switch left
       (t
        (switch-to-buffer (nth (- n 1) knavemacs/tab-line-buffers-list))))))

  ;; function for removing a tab for a buffer - non-nil argument ensures buffer is killed
  (defun knavemacs/tab-line-drop-tab (&optional kill)
    "Remove the tab for the current buffer. Will KILL indirect buffers, but leave all others open."
    (interactive)
    (let ((buffer-to-drop (current-buffer)))
      (knavemacs/tab-line-switch-before-drop-kill)
      ;;if buffer is indirect, dired, help or kill is non-nil, kill-this-buffer, otherwise remove from tab-list (keeping buffer open)
      (if (or kill
              (buffer-base-buffer buffer-to-drop)
              ;;buffer-file-name is blank for dired and help descriptions, so kill those buffers
              (not (buffer-file-name buffer-to-drop)))
          (kill-buffer buffer-to-drop)
        (setq knavemacs/tab-line-buffers-list (delete buffer-to-drop knavemacs/tab-line-buffers-list))))
    (set-window-parameter nil 'tab-line-cache nil)
    (force-mode-line-update))

  ;; convieneince function for killing a buffer/tab
  (defun knavemacs/tab-line-kill-tab ()
    "Kill the buffer and tab active in the tab-line"
    (interactive)
    (knavemacs/tab-line-drop-tab t))


  ;; set the hook to update the tab-line on buffer changes
  (add-hook 'buffer-list-update-hook #'knavemacs/tab-line-add-current-buffer)
  )
#+END_SRC

*** Dired Mode Configuration
#+BEGIN_SRC elisp
  (use-package dired
    :ensure nil
    :bind
    (("M-i" . emacs-solo/window-dired-vc-root-left))
    :custom
    (dired-dwim-target t)
    (dired-guess-shell-alist-user
     '(("\\.\\(png\\|jpe?g\\|tiff\\)" "feh" "xdg-open" "open")
       ("\\.\\(mp[34]\\|m4a\\|ogg\\|flac\\|webm\\|mkv\\)" "mpv" "xdg-open" "open")
       (".*" "xdg-open" "open")))
    (dired-kill-when-opening-new-dired-buffer t)
    (dired-listing-switches "-alh --group-directories-first")
    (dired-omit-files "^\\.")                                ; with dired-omit-mode (C-x M-o)
    (dired-hide-details-hide-absolute-location t)            ; EMACS-31
    :init
    (add-hook 'dired-mode-hook (lambda () (dired-omit-mode 1))) ;; Turning this ON also sets the C-x M-o binding.

    (defun emacs-solo/window-dired-vc-root-left (&optional directory-path)
      "Creates *Dired-Side* like an IDE side explorer"
      (interactive)
      (add-hook 'dired-mode-hook 'dired-hide-details-mode)

      (let ((dir (if directory-path
                     (dired-noselect directory-path)
                   (if (eq (vc-root-dir) nil)
                       (dired-noselect default-directory)
                     (dired-noselect (vc-root-dir))))))

        (display-buffer-in-side-window
         dir `((side . left)
               (slot . 0)
               (window-width . 30)
               (window-parameters . ((no-other-window . t)
                                     (no-delete-other-windows . t)
                                     (mode-line-format . (" "
                                                          "%b"))))))
        (with-current-buffer dir
          (let ((window (get-buffer-window dir)))
            (when window
              (select-window window)
              (rename-buffer "*Dired-Side*")
              )))))

    (defun emacs-solo/window-dired-open-directory ()
      "Open the current directory in *Dired-Side* side window."
      (interactive)
      (emacs-solo/window-dired-vc-root-left (dired-get-file-for-visit)))

    (eval-after-load 'dired
      '(progn
         (define-key dired-mode-map (kbd "C-<return>") 'emacs-solo/window-dired-open-directory))))

#+END_SRC

*** Window Switching ("ace-window")
#+BEGIN_SRC elisp
  (use-package emacs-solo-ace-window
    :ensure nil
    :no-require t
    :defer t
    :init
    (defvar emacs-solo-ace-window/quick-window-overlays nil
      "List of overlays used to temporarily display window labels.")

    (defun minknavemacs/quick-window-jump ()
  	"If there are only two windows, jump to the other. Otherwise, initiate quick jumping."
  	(interactive)
  	(if (= (length (window-list)) 2)
  		(call-interactively 'other-window)
  	  (emacs-solo-ace-window/quick-window-jump)))
    
    (defun emacs-solo-ace-window/quick-window-jump ()
      "Jump to a window by typing its assigned character label.
  Windows are labeled starting from the top-left window and proceeding top to bottom, then left to right."
      (interactive)
      (let* ((window-list (emacs-solo-ace-window/get-windows))
             (window-keys (seq-take '("1" "2" "3" "4" "5" "6" "7" "8")
                                    (length window-list)))
             (window-map (cl-pairlis window-keys window-list)))
        (emacs-solo-ace-window/add-window-key-overlays window-map)
        (let ((key (read-key (format "Select window [%s]: " (string-join window-keys ", ")))))
          (emacs-solo-ace-window/remove-window-key-overlays)
          (if-let* ((selected-window (cdr (assoc (char-to-string key) window-map))))
              (select-window selected-window)
            (message "No window assigned to key: %c" key)))))

    (defun emacs-solo-ace-window/get-windows ()
      "Return a list of windows in the current frame, ordered from top to bottom, left to right."
      (sort (window-list nil 'no-mini)
            (lambda (w1 w2)
              (let ((edges1 (window-edges w1))
                    (edges2 (window-edges w2)))
                (or (< (car edges1) (car edges2)) ; Compare top edges
                    (and (= (car edges1) (car edges2)) ; If equal, compare left edges
                         (< (cadr edges1) (cadr edges2))))))))

    (defun emacs-solo-ace-window/add-window-key-overlays (window-map)
      "Add temporary overlays to windows with their assigned key labels from WINDOW-MAP."
      (setq emacs-solo-ace-window/quick-window-overlays nil)
      (dolist (entry window-map)
        (let* ((key (car entry))
               (window (cdr entry))
               (start (window-start window))
               (overlay (make-overlay start start (window-buffer window))))
          (overlay-put overlay 'after-string
                       (propertize (format " [%s] " key)
                                   'face '(:foreground "#c3e88d"
                                                       :background "#232635"
                                                       :weight bold
                                                       :height default)))
          (overlay-put overlay 'window window)
          (push overlay emacs-solo-ace-window/quick-window-overlays))))

    (defun emacs-solo-ace-window/remove-window-key-overlays ()
      "Remove all temporary overlays used to display key labels in windows."
      (mapc 'delete-overlay emacs-solo-ace-window/quick-window-overlays)
      (setq emacs-solo-ace-window/quick-window-overlays nil))

    (global-set-key (kbd "M-p") #'emacs-solo-ace-window/quick-window-jump))

#+END_SRC

*** Highlight Keywords Function
#+BEGIN_SRC elisp
  ;;; EMACS-SOLO-HIGHLIGHT-KEYWORDS-MODE
  ;;
  ;;  Highlights a list of words like TODO, FIXME...
  ;;  Code borrowed from `alternateved'
  ;;
  (use-package emacs-solo-highlight-keywords-mode
    :ensure nil
    :no-require t
    :defer t
    :init
    (defcustom +highlight-keywords-faces
      '(("TODO" . error)
        ("FIXME" . error)
        ("HACK" . warning)
        ("NOTE" . warning)
        ("HERE" . compilation-info)
        ("EMACS-31" . compilation-info))
      "Alist of keywords to highlight and their face."
      :group '+highlight-keywords
      :type '(alist :key-type (string :tag "Keyword")
                    :value-type (symbol :tag "Face"))
      :set (lambda (sym val)
             (dolist (face (mapcar #'cdr val))
               (unless (facep face)
                 (error "Invalid face: %s" face)))
             (set-default sym val)))

    (defvar +highlight-keywords--keywords
      (when +highlight-keywords-faces
        (let ((keywords (mapcar #'car +highlight-keywords-faces)))
          `((,(regexp-opt keywords 'words)
             (0 (when (nth 8 (syntax-ppss))
                  (cdr (assoc (match-string 0) +highlight-keywords-faces)))
                prepend)))))
      "Keywords and corresponding faces for `emacs-solo/highlight-keywords-mode'.")

    (defun emacs-solo/highlight-keywords-mode-on ()
      (font-lock-add-keywords nil +highlight-keywords--keywords t)
      (font-lock-flush))

    (defun emacs-solo/highlight-keywords-mode-off ()
      (font-lock-remove-keywords nil +highlight-keywords--keywords)
      (font-lock-flush))

    (define-minor-mode emacs-solo/highlight-keywords-mode
      "Highlight TODO and similar keywords in comments and strings."
      :lighter " +HL"
      :group '+highlight-keywords
      (if emacs-solo/highlight-keywords-mode
          (emacs-solo/highlight-keywords-mode-on)
        (emacs-solo/highlight-keywords-mode-off)))

    :hook
    (prog-mode-hook . (lambda () (run-at-time "1 sec" nil #'emacs-solo/highlight-keywords-mode-on))))

#+END_SRC

** Keybindings
*** Additional Emacs Keybindings
#+BEGIN_SRC elisp
  (use-package minknavemacs-keybindings
    :ensure nil
    :no-require t
    :defer t
    :after viper
    :bind
    (("M-o" . other-window)
     ("M-d" . duplicate-dwim)
     ("M-L" . enlarge-window-horizontally)
     ("M-K" . shrink-window)
     ("M-J" . enlarge-window)
     ("M-H" . shrink-window-horizontally)
     ("M-l" . windmove-right)
     ("M-k" . windmove-up)
     ("M-j" . windmove-down)
     ("M-h" . windmove-left)
     ("M-n" . completion-at-point)
     ("M-g r" . recentf)
     ("M-s g" . grep)
     ("C-x ;" . comment-line)
     ("M-s f" . find-name-dired)
     ("C-x C-b" . ibuffer)
     ("RET" . newline-and-indent))
    ) 
#+END_SRC

** (External Packages)
*** Package Configuration
I try to limit the inclusion of external packages, but will not shy away from
using them if they provide a bespoke benefit to my configuration or usage of
Emacs in general.
#+BEGIN_SRC elisp
  ;; define package sources and config
  (require 'package)
  (setq package-archives '(("melpa" . "https://melpa.org/packages/")
  		     ("org" . "https://orgmode.org/elpa/")
  		     ("elpa" . "https://elpa.gnu.org/packages/")
  		     ))
  (package-initialize)
  (unless package-archive-contents
    (package-refresh-contents))

  ;; use-package setup
  (unless (package-installed-p 'use-package)
    (package-install 'use-package))
  (require 'use-package)
#+END_SRC

*** Core External
**** Modal Editing Keybindings
#+BEGIN_SRC emacs-lisp
  (use-package ryo-modal
    :ensure t
    :load-path "~/.config/emacs/modal"
    :commands ryo-modal-mode
    :bind
    ("C-z" . ryo-modal-mode) ;; backup
    ("`" . ryo-modal-mode) ;; intended key
    ("C-`" . minknavemacs/modal-print-backtick) ;; can still print this character 
    :config
    (require 'minknavemacs-keyfunc)
    (define-key ryo-modal-mode-map (kbd "SPC h") 'help-command)
    
    (define-key ryo-modal-mode-map (kbd "SPC x") ctl-x-map)
    (define-key ctl-x-map (kbd "s") #'(lambda () (interactive) (if ryo-modal-mode (save-buffer) (save-some-buffers))))
    (define-key ctl-x-map (kbd "f") #'minknavemacs/modal-find-file) ;; needs to be called interactively
    (define-key ctl-x-map (kbd "c") #'save-buffers-kill-terminal)
    (define-key ctl-x-map (kbd "j") #'dired-jump)

    (ryo-modal-key
     "SPC" '(("SPC" switch-to-buffer)
  		   ("k" kill-current-buffer)
  		   ("b b" ibuffer)
  		   ("b k" kill-buffer)
  		   ("o c" org-capture)
  		   ("o a" org-agenda)
  		   ("o t" minknavemacs/org-quick-time-stamp-inactive)
  		   ("o l" org-store-link)))
    
    (ryo-modal-keys
     ("," minknavemacs/scroll-up-half-page)
     ("." minknavemacs/scroll-down-half-page)
     ("<" beginning-of-buffer)
     (">" end-of-buffer)
     ("{" backward-paragraph)
     ("}" forward-paragraph)
     (";" ryo-modal-repeat)
     ("a" beginning-of-line :exit t)
     ("A" end-of-line :exit t)
     ("b" backward-word)
     ("B" minknavemacs/modal-backward-symbol)
     ("c" kill-ring-save)
     ("C" append-next-kill)
     ("d" kill-region)
     ("D" kill-line)
     ("e" forward-sexp)
     ("E" backward-sexp)
     ("f" transpose-words)
     ("F" transpose-lines)
     ("g"
  	(("g"
  	  keyboard-quit)
  	 ("v"
  	  minknavemacs/jump-back-to-mark)
  	 ("V"
  	  exchange-point-and-mark)
  	 ("u"
  	  universal-argument)))
     ("h" backward-char)
     ("H" beginning-of-line)
     ("i" ryo-modal-mode)
     ("I" overwrite-mode :exit t)
     ("j" next-line)
     ("J" minknavemacs/modal-shift-point-bottom)
     ("k" previous-line)
     ("K" minknavemacs/modal-shift-point-top)
     ("l" forward-char)
     ("L" end-of-line)
     ("m" avy-goto-char-timer)
     ("M" move-to-window-line-top-bottom)
     ("n" er/expand-region)
     ("N" er/contract-region)
     ("o" minknavemacs/modal-open-line-below :exit t)
     ("O" minknavemacs/modal-open-line-above :exit t)
     ("p"
  	(("p"
  	  recenter
  	  :name "Push to center window")
  	 ("t"
  	  minknavemacs/modal-recenter-top
  	  :name "Push to top of window")
  	 ("b"
  	  minknavemacs/modal-recenter-bottom
  	  :name "Push to bottom of window")))
     ("P" recenter-other-window)
     ("Q" revert-buffer)
     ("r" backward-delete-char-untabify :read t)
     ("R" query-replace)
     ("s" isearch-forward)
     ("S" isearch-backward)
     ("t" zap-up-to-char)
     ("T" zap-to-char)
     ("u" undo)
     ("U" undo-redo)
     ("v" set-mark-command)
     ("V" minknavemacs/modal-set-mark-line)
     ("w" forward-word)
     ("W" forward-symbol)
     ("x" delete-char)
     ("X" backward-delete-char-untabify)
     ("y" yank)
     ("Y" yank-pop)
     ("z"
  	(("z"
  	  delete-other-windows)
  	 ("x"
  	  delete-window)
  	 ("c"
  	  split-window-below)
  	 ("v"
  	  split-window-right)
  	 ("o"
  	  minknavemacs/quick-window-jump)
  	 ("h"
  	  windmove-left)
  	 ("j"
  	  windmove-down)
  	 ("k"
  	  windmove-up)
  	 ("l"
  	  windmove-right)))
     ("Z"
  	(("c"
  	  enlarge-window
  	  :properties ((repeat-map . minknavemacs/window-manage-repeat-map)))
  	 ("C"
  	  shrink-window
  	  :properties ((repeat-map . minknavemacs/window-manage-repeat-map)))
  	 ("v"
  	  enlarge-window-horizontally
  	  :properties ((repeat-map . minknavemacs/window-manage-repeat-map)))
  	 ("V"
  	  shrink-window-horizontally
  	  :properties ((repeat-map . minknavemacs/window-manage-repeat-map)))))
     )


    (ryo-modal-keys
     ;; First argument to ryo-modal-keys may be a list of keywords.
     ;; These keywords will be applied to all keybindings.
     (:norepeat t)
     ("0" "M-0")
     ("1" "M-1")
     ("2" "M-2")
     ("3" "M-3")
     ("4" "M-4")
     ("5" "M-5")
     ("6" "M-6")
     ("7" "M-7")
     ("8" "M-8")
     ("9" "M-9"))

    ;; try to enter modal mode each time we move to a new context
    (add-hook 'after-change-major-mode-hook 'ryo-modal-mode)
    )
#+END_SRC

**** Vertico Completions
#+BEGIN_SRC elisp
  ;; PURPOSE: minimal completion system in the likes of helm and ivy
  (use-package vertico
    :ensure t
    :bind (:map vertico-map
                ("C-j" . vertico-next)
                ("C-k" . vertico-previous)
                ("C-f" . vertico-exit)
                :map minibuffer-local-map
                ("C-h" . backward-kill-word))
    :custom
    (vertico-cycle t)
    :init
    (vertico-mode))

  ;; PURPOSE: built in emacs package that works with vertico, show recent completion selections used
  (use-package savehist
    :ensure t
    :init
    (savehist-mode))

  ;; PURPOSE: provides extra metadata in margins of vertico completions
  (use-package marginalia
    :ensure t
    :after vertico
    :custom
    (marginalia-annotators '(marginalia-annotators-heavy marginalia-annotators-light nil))
    :init
    (marginalia-mode))

  ;; PURPOSE: provides and orderless algorithm for fuzzy finding
  (use-package orderless
    :ensure t
    :custom
    (completion-styles '(orderless basic))
    (completion-category-overrides '((file (styles basic partial-completion)))))
#+END_SRC

**** Nerd Icons
I use nerd icons to leverage the full capabilities of the fonts I choose to use
in both the terminal as well as GUI Emacs. Alongside the base package, I use
some other companion packages to add some visual eyecandy to various places.
#+BEGIN_SRC elisp
  ;; PACKAGE: nerd-icons
  ;; PURPOSE: fancy icons in GUI and terminal emacs
  (use-package nerd-icons
    :ensure t
    )

  ;; PACKAGE: nerd-icons-completion
  ;; PURPOSE: fancy icons in completion buffers
  (use-package nerd-icons-completion
    :ensure t
    :after vertico marginalia nerd-icons
    :config
    (nerd-icons-completion-mode)
    (add-hook 'marginalia-mode-hook #'nerd-icons-completion-marginalia-setup))

  ;; PACKAGE: nerd-icons-dired
  ;; PURPOSE: fancy icons in dired buffers
  (use-package nerd-icons-dired
    :ensure t
    :init (add-hook 'dired-mode-hook #'nerd-icons-dired-mode))

  ;; PACKAGE: nerd-icons-ibuffer
  ;; PURPOSE: fancy icons in ibuffer
  (use-package nerd-icons-ibuffer
    :ensure t
    :init (add-hook 'ibuffer-mode-hook #'nerd-icons-ibuffer-mode))

  ;; PACKAGE: nerd-icons-corfu
  ;; PURPOSE: fancy icons in corfu completion windows
  (use-package nerd-icons-corfu
    :ensure t
    :after corfu
    :config
    (add-to-list 'corfu-margin-formatters #'nerd-icons-corfu-formatter))
#+END_SRC

**** Avy Jump to Point
#+BEGIN_SRC elisp
  ;; Install Avy - jump to location based on char decision tree
  (use-package avy
    :ensure t
    :config
    ;; define an avy action to kill a while line based on a selection
    ;; (see https://karthinks.com/software/avy-can-do-anything/)
    (defun avy-action-kill-whole-line (pt)
      (save-excursion
  	(goto-char pt)
  	(kill-whole-line))
      (select-window
       (cdr
  	(ring-ref avy-ring 0)))
      t)

    ;; add custom avy actions to the action dispatcher
    (setf (alist-get ?K avy-dispatch-alist) 'avy-action-kill-whole-line
  		)
    )
#+END_SRC

**** Expand Region
#+BEGIN_SRC emacs-lisp
  (use-package expand-region
    :ensure t
    )
#+END_SRC

*** Productivity External
**** Howm Note Taking
#+BEGIN_SRC elisp
  (use-package howm
    :ensure t
    :init
    (setq howm-directory "~/Documents/knowledge/")
    (setq howm-home-directory howm-directory)
    (setq howm-keyword-file (expand-file-name ".howm-keys" howm-home-directory))
    (setq howm-history-file (expand-file-name ".howm-history" howm-home-directory))
    (setq howm-file-name-format "%Y/%m/%Y%m%d%H%M%S.md")
    (setq howm-view-title-header "#")
    (setq howm-prefix (kbd "C-c N")) ; shortcut using meow keypad <SPC>-N
    )

  ;; FIXME -- ONLY WORKS WITH MEOW CONFIG
  ;; I need to rewrite this as a function:

  ;; The following macro creates a link in
  ;; the current howm note to another howm note
  ;; *NOTE* This assumes the howm note to be linked
  ;; is the most recently visited buffer besides the current one
  ;;
  ;; The link that is created is in the format below:
  ;; [[filename without extension]] >>> Note Header
  ;; This is useful since the part of the link after >>> can be followed
  ;; in howm, but the first part of the link in [[]] can be followed
  ;; using a tool like obsidian
  (defalias 'knavemacs-howm-link-from-buffers-kmacro
    (kmacro "C-x b <return> C-c n K C-x b <return> i > > > SPC <escape> p , i [ [ <right> <right> SPC <left> <left> <left> <escape> C-x b <return> C-u C-c n K C-x b <return> p <left> <left> <left> x x x C-u - f / g C-u - f ~ d x ."))


  ;; The following functions allow me to create howm notes with not
  ;; just the default datetime stamp as the note file name, but also
  ;; incorporate the sluggified main header within the note file name as well,
  ;; which is helpful for my own personal tastes and workflow.
  (defun minknavemacs/denote-slug-hyphenate (str)
    "Replace spaces and underscores with hyphens in STR.
  Also replace multiple hyphens with a single one and remove any
  leading and trailing hyphen. This was taken from the denote package."
    (replace-regexp-in-string
     "^-\\|-$" ""
     (replace-regexp-in-string
      "-\\{2,\\}" "-"
      (replace-regexp-in-string "_\\|\s+" "-" str))))

  (defun minknavemacs/denote-sluggify-value (str)
    "Make STR an appropriate slug for title. This
  was taken from the denote package."
    (downcase
     (knavemacs/denote-slug-hyphenate
      (replace-regexp-in-string "[][{}!@#$%^&*()+'\"?,.\|;:~`‘’“”/=]*" "" str))))

  (defun minknavemacs/howm-create-with-descriptive-filename ()
    "Create a new howm note using the standard file naming scheme,
  with the addition of the first header sluggified and added to the filename."
    (interactive)
    (let* ((header (read-string "Enter Note Title: "))
           (sluggified-header (knavemacs/denote-sluggify-value header))
           (datestamp (format-time-string "%Y%m%d%H%M%S"))
           (descriptive-filename (concat datestamp "-" sluggified-header ".md"))
           (descriptive-directory (format-time-string "%Y/%m/"))
           )
      (find-file (concat howm-directory descriptive-directory descriptive-filename))
      (goto-char (point-max))
      (howm-create-here)
      (insert header)
      ))
#+END_SRC

**** Markdown Mode
#+BEGIN_SRC elisp
  (use-package markdown-mode
    :ensure t)
#+END_SRC

*** Programming External
**** Corfu Completions
#+BEGIN_SRC elisp
  (use-package corfu
    :ensure t
    :init
    (global-corfu-mode)
    (corfu-popupinfo-mode 1))
#+END_SRC

**** Cape Completion Functions
#+BEGIN_SRC elisp
  (use-package cape
    ;; Bind prefix keymap providing all Cape commands under a mnemonic key.
    ;; Press C-c p ? to for help.
    :bind ("M-N" . cape-prefix-map) ;; Alternative key: M-<tab>, M-p, M-+
    ;; Alternatively bind Cape commands individually.
    ;; :bind (("C-c p d" . cape-dabbrev)
    ;;        ("C-c p h" . cape-history)
    ;;        ("C-c p f" . cape-file)
    ;;        ...)
    :init
    ;; Add to the global default value of `completion-at-point-functions' which is
    ;; used by `completion-at-point'.  The order of the functions matters, the
    ;; first function returning a result wins.  Note that the list of buffer-local
    ;; completion functions takes precedence over the global list.
    (add-hook 'completion-at-point-functions #'cape-dabbrev)
    (add-hook 'completion-at-point-functions #'cape-file)
    (add-hook 'completion-at-point-functions #'cape-elisp-block)
    ;; (add-hook 'completion-at-point-functions #'cape-history)
    ;; ...
    )
#+END_SRC

**** Yasnippet
#+BEGIN_SRC elisp
  (use-package yasnippet
    :ensure t
    :config
    (setq yas-snippet-dirs
  	  '("~/Documents/data/snippets"))
    (yas-global-mode 1) ;; or M-x yas-reload-all if YASnippet is already started
    )

  (use-package yasnippet-capf
    :after cape
    :config
    (add-to-list 'completion-at-point-functions #'yasnippet-capf))
#+END_SRC

*** Visual External
**** Rainbow Mode
#+BEGIN_SRC elisp
  ;; PACKAGE: rainbow-mode
  ;; PURPOSE: provide color highlighting for rgb/hex codes in the buffer
  (use-package rainbow-mode
    :ensure t)
#+END_SRC

